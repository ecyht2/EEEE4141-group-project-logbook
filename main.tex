\documentclass[12pt]{article}
\usepackage{nottingham-logbook}
\usepackage{nott-titlepage}
\usepackage{hyperref}
\usepackage{graphicx}

\title{Group Project Logbook}
\author{Tan Hong Kai}
\studentid{20386501}
\date{Year 2023 - 2024}
\department{Department of Electrical and Electronics Engineering}

\begin{document}
\maketitle

\begin{logbook-entry}{Map Logic}{22}{29/01/2024}{02/02/2024}
One of the main goals of the desktop application is to set the path the boat is going to follow.
This will inform the boat where the temperature data should be collected.

The user can input waypoints for the boat to reach.
This will determine the path the boat will follow.
The Maplibre JS provides a way to listen when the user clicks on the map.
A new waypoint can be added at the location the user clicked on.

The path can then be generated using the waypoints.
Currently, the path follows the order the points is added.
This will cause the path to intersect.
This is not ideal as this will cause duplication of data points.
A better algorithm is needed to generate a path that does not intersect.
\end{logbook-entry}

\begin{logbook-entry}{Map Logic 2}{23}{05/02/2024}{09/02/2024}
When planning a path for the robot boat to follow, it is essential to move waypoints around.
This allows users to try out different configurations with different way point positions.

Maplibre has a special map item for marking points that can be moved around.
A marker can be used to mark specific important points on the map.
The marker can then be dragged around the map.

When a marker is moved, the new location of the marker can be used as a new waypoint.
This can be done using the "drag" event emitted by the marker.
The "drag" event contains information about the new coordinate the marker is on.
The path then can update accordingly based on the new coordinate.
\end{logbook-entry}

\begin{logbook-entry}{Import Export}{25}{19/02/2024}{23/02/2024}
The map on the desktop application is only capable of display on route at a time.
However, the stakeholder might want to collect data from multiple different water-body and or set multiple paths for the same water body.

The desktop application should have a way to import and export paths.
This allows the user to save paths for different data collection tasks.

GeoJSON is a file format for describing geographical features.
There are several types of features:

\begin{itemize}
    \item Point
    \item LineString
    \item Polygon
    \item MultiPoint
    \item MultiLineString
    \item MultiPolygon
    \item GeometryCollection
\end{itemize}

Maplibre JS has built in support for displaying data in GeoJSON, making it a suitable file format for storing the path.
The GeoJSON file being imported and exported is made out of a FeatureCollection.
The feature collection contains the following features:

\begin{itemize}
    \item MultiPoint feature used to describe all the location where the data is going to be collected.
    \item LineString feature used to describe the path the boat is going to follow.
    \item A version foreign member to describe what version of the file format being used (useful for future changes to the file format).
\end{itemize}

This format is used both internally by the application and external for user import and export.
Every time the user changes the path and or collection point, the path is saved to the application's internal storage.
Exporting and importing paths can be done using buttons.
The buttons will display a file picker to choose where to save the file to or which file to import from.

The state of the path used by Maplibre is serialized and deserialized using the serde library.
However, whenever something is imported, a function would check the validity of the GeoJSON file.
This is to ensure the required items are present in the file being imported.

\subsection*{Resources}

\begin{itemize}
    \item \href{https://datatracker.ietf.org/doc/html/rfc7946}{GeoJSON RFC}
\end{itemize}

\end{logbook-entry}

\begin{logbook-entry}{Heatmap}{26}{26/02/2024}{01/03/2024}
A heatmap is a good way to display the temperature variation in an area.
A heatmap can be used to display temperature information using different colour.
For example, a red area represents high temperature while a blue area represents a cold area.

A heatmap is a good feature for the desktop application to quickly interpret the data received from the robot.
However, for further analysis of the collected data, the data has to be exported.

Maplibre JS provides a way to display heatmap data.
A heatmap layer for Maplibre can customize the colour of the heatmap based on density of the heat map in a spot.
The heatmap weight and intensity controls the density of the heatmap at a point on the map.
The heatmap colour can be modified to change the colour based on the density of the heatmap.
Lastly, the radius of each data point controls how spread out the heatmap is, and the opacity controls the opacity of the heatmap.

Scientists and data analysis used spreadsheet program to process data.
There are many formats available that are compatible with spreadsheets.
Some notable examples are:

\begin{itemize}
    \item Excel Spreadsheet (.xls/.xlsx)
    \item XML (.xml)
    \item Comma-separated Values (CSV) (.csv)
    \item OpenDocument (.ods)
\end{itemize}

The main format to import and export data from the desktop application is Comma-separated Values.
It is a plain text file format that is easy to understand and universal.
Most/all spreadsheet programs have built in support for parsing CSV.
There are also plenty of libraries in many programming languages such as Python to parse CSV as well.
The universality and standardization of this file format is the main reason why CSV is used.

An additional file format is used for internal used of the application.
The file format is GeoJSON.
This is due to the fact that the Maplibre JS library expects data to be in this format.
Saving the results in this format makes sense and simplifies the logic to display the heatmap.

\subsection*{The CSV Format}

The CSV file format is a plain text format to store data.
Each line represents a specific record of data.
The values for each record are separated using commas, hence the name comma-separated values.
An optional heading row can be set using the first row of the CSV file.

The data exported from the desktop application have the following values:

\begin{itemize}
    \item The temperature in \textdegree{C}
    \item The depth in millimetres
    \item The layer in water body the temperature is collected at (Sea Bed, Middle or Surface)
    \item The timestamp of the data in Unix Time
    \item The latitude coordinate of the data point
    \item The longitude coordinate of the data point
\end{itemize}
\end{logbook-entry}

\begin{logbook-entry}{Path Generation}{27}{04/03/2024}{08/03/2024}
The path generation and points interpolation algorithm is worked on.

\subsection*{Path Generation}
A simple algorithm is used to generate the path followed by the boat.
The algorithm can be split into a few main logic.

\begin{enumerate}
    \item Pick an initial starting point of the boat (the first point inserted by the user)
    \item Find the nearest point to the initial point (using Haversine formula (provided by Maplibre JS library))
    \item Add the nearest point to the path
    \item Use repeat step 2 with the new point as the new initial point
    \item The algorithm ends when all the input points are used
\end{enumerate}

The algorithm is simple and works but will sometimes generate path that intersects.
This is not ideal as this would mean the boat will collect redundant data (data in the same coordinate).
However, this is good enough for now but a better algorithm can be used.

\subsection*{Point Interpolation}
The Haversine Formula can be used to interpolate the points in between the path.
This can be done by using the bearing from the staring to the ending point of the path and the distance from the starting point.
The equations are shown below:

New Latitude:
\begin{equation}
    \phi{}_{2} = \arcsin{(\sin{\phi{}_{1}} \cos{\delta} + \cos{\phi{}_{1}} \sin{\delta} \cos{\theta})}
\end{equation}

New Longitude:
\begin{equation}
    \lambda{}_{2} = \lambda{}_{1} + \arctan{(\frac{\sin{\theta} \sin{\delta} \cos{\phi{}_{1}}}{\cos{\delta} - \sin{\phi_{1} \sin{\phi_{2}}}})}
\end{equation}

Variables:

$\delta = d / R$

$d = $ distance from the starting point

$R = $ the radius of Earth

$\phi_1 = $ The latitude of the starting point

$\lambda_1 = $ The longitude of the starting point

$\theta = $ The bearing from north

\subsection*{Resources}
\begin{itemize}
    \item \href{https://stackoverflow.com/questions/14263284/create-non-intersecting-polygon-passing-through-all-given-points}{Better Path Generation}
    \item \href{https://www.movable-type.co.uk/scripts/latlong.html}{Haversine Formula}.
\end{itemize}
\end{logbook-entry}

\begin{logbook-entry}{Communication Protocol}{28}{11/03/2024}{15/03/2024}
The communication protocol is worked on.
The main task of the communication protocol is to facilitate communication between the desktop application and the robot boat.
The desktop application would send the route generated by the user to the boat.
The boat would send the data collected to the desktop application for further processing.

\subsection*{Communication Medium}

There are a few ways to send data between the boat and the desktop application.
Some mediums considered were:

\begin{itemize}
    \item Radio Frequency Communication using nRF24L01
    \item Serial Communication through USB Cables
    \item Bluetooth Connection with the Raspberry Pi
    \item Simple TCP Connection using Wi-Fi with the Raspberry Pi
\end{itemize}

\begin{table}[ht]
    \centering
    \caption{Table Comparing All the Communication Mediums}
    \label{tab:comm-medium}
    \vspace{1em}
    \begin{tabular}{ p{7em} p{10em} p{10em} }
        Communication Medium & Advantages                                               & Disadvantages                                                              \\
        \hline
        RF                   & Wireless, Does not need connection with the Raspberry Pi & Slow and Limited Packet Size                                               \\
        \hline
        USB Cable            & Simple and Practical                                     & Requires physical access to the boat                                       \\
        \hline
        Bluetooth            & Wireless, Easy discovery of robot                        & Requires Bluetooth connection with the Raspberry Pi, short range           \\
        \hline
        TCP                  & Wireless, Fast data transfers                            & Requires LAN connection with Pi, medium range, compatible with all laptops \\
        \hline
    \end{tabular}
\end{table}

A comparison between all the communication mediums are shown in table \ref{tab:comm-medium}.
Each of the mediums were carefully considered and compared.
The serial communication using USB cables are chosen at the end.

The RF communication isn't considered due to the low packet sizes and sending speed.
This can be circumvented by splitting the data into multiple packets.

However, sending multiple packets will take time as each packet send has an estimated delay of around 1 ms.

TCP connection isn't considered due to requiring connecting the Raspberry Pi to the same WLAN network (mobile hotspot).
This is hard to achieve without access to the GUI output of Raspberry Pi.

The short range of the Bluetooth protocol limits its usability for our application.
The benefits of being wireless is that data can be transferred while the boat is operating.
The Bluetooth connection would constantly disconnect and or the user needs to stay close to the boat to maintain the connection.

Even though the lack of wireless capabilities of the USB cable, this will not cause too much inconvenience for the user.
Before and after each operation of the boat, the user need to collect/place down the boat.
The user will have physical access to the boat and therefore can use the USB cable.
\end{logbook-entry}

\end{document}
