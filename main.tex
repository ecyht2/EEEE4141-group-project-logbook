\documentclass[12pt]{article}
\usepackage{nottingham-logbook}
\usepackage{nott-titlepage}
\usepackage{hyperref}
\usepackage{float}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{Group Project Logbook}
\author{Tan Hong Kai}
\studentid{20386501}
\date{Year 2023 - 2024}
\department{Department of Electrical and Electronics Engineering}

\begin{document}
\maketitle

\begin{logbook-entry}{Project Breifing}{4}{25/09/2023}{29/09/2023}
I have a project breifing about what is the design requirments of this year's group project.
This year's group project is to create an autonomous vehicle to profile water temperature in a water body.
The vehicle must sample data from 3 different depths, water surface, middle and sea bed.

I come up with a few concepts of the project.
One of the concepts is a boat that is connected to the internet.
The boat will receive path from a web-server.
To collect data, there will be system to lower down a depth and temperture sensor.

The user would add points on a map to tell where the boat will sample the data.
The data would be sent to a database in which the boat request the points.
When the data is collected, the boat will send the data back to the web-server for storage.
The web client will then fetch the data collected from the database and display it.
\end{logbook-entry}

\begin{logbook-entry}{Project Discussion}{5}{02/10/2023}{06/10/2023}
My group decided that we should come up with our own ideas and we share it this week.    
We have a casual meeting dicussing on what we came up with.
We also discussed on potential solutions and potential issues that can arise from the solution.

My grouped decided to design a boat with a pulley system attached.
The system would be controlled by a single Raspberry Pi.
The user of the boat would interface with a web application to control the boat.

I will be tasked in making the web application.
My other teammates are tasked with other parts of the boat.
The different tasks splits are:
\begin{itemize}
    \item Boat and Pulley Structure
    \item Boat Power System
    \item Boat Control and Logic
    \item User Interface for the Boat
\end{itemize}

We also discussed on the project schedule and hardware requirments.
Every group has a fixed budget and should send all the hardware purchases before the Finance office closes.
Since my part does not require hardware, I won't be using any of our budget.

I also created a draft Gantt Chart for the project.
This will be act as a timeline for us to follow.
We discussed on what should be on the timeline and how long each task should last.

The Gantt Chart is created in Excel.
We will try our best to follow the schedule throughout the year.
Hopefully, we can manage our time well and finish the project in time and within the timeline.
\end{logbook-entry}

\begin{logbook-entry}{Web Frameworks}{6}{09/10/2023}{13/10/2023}
A web server plays a core part of the project.
The server serves as the center where the boat and the user interface communicate with each other.
There are many frameworks to help creating a web server.
Many frameworks a written in different programming langauages and thus offer different benifits.
I list some common languages and their respective framework and compare them with each other.

\begin{table}[H]
    \centering{}
    \caption{Table Comparing Different Languages Used for Servers}
    \begin{tabularx}{\textwidth}{l X X}
        \hline
        Language & Advantages & Disadvantages\\
        \hline
        JavaScript & Same language as frontend, simple to use & Performance issues, requires custom runtime\\
        PHP & Well tested and used in the industry & Required to learn a specific language\\
        Ruby & Simple to learn, easy to read & Required to learn a specific language\\
        Python & Widely used language, massive community support & Performance issues, dynamic language causing potential bugs\\
        Rust & Stable, type safety, built-in concurrency & Hard to write, long development time\\
        Go & Fairly easy to write, fast to compile, type safety & Hard to do complex task\\
        \hline
    \end{tabularx}
\end{table}

The Rust language is chosen for it's performance and stability.
The Go language is an interesting choice in my opinion but I would need to learn a new lanague.
This will use more time that I might not have.
This is also the main reason why I didn't choose PHP and Ruby which are two lanagues that I don't know.
JavaScript and Python are both languages that is widely supported and used.
However, the performance issues makes it not ideal for running algorithms such as path generation for the boat.

There are three main frameworks in Rust.
They are: Rocket, Actix Web and Axum.
Rocket is a good and stable choice but lacks new updates.
Axum is very new and is unstable with breaking changes.
Therefore, Actix web is chosen due to it's stability and frequent updates.
\end{logbook-entry}

\begin{logbook-entry}{Database Research}{7}{16/10/2023}{20/10/2023}
A database is responsible for storing paths from the user and data from the boat.
When the user asks for data, the web-server fetches the data from the database.
There are many database implementations, each one with their own advantages and disadvantages.
I researched some common database and compare them in table \ref{tab:db-comparison}.

\begin{table}[H]
    \centering{}
    \caption{Table Comparing Different Databases}
    \label{tab:db-comparison}
    \begin{tabularx}{\textwidth}{m{5em} X X}
        \hline
        Database & Advantages & Disadvantages\\
        \hline
        SQLite & Embedable in software, light weight & No parallel insertions\\
        PostgreSQL & Support for custom data types, good third party integration & Incomplete documentation\\
        MySQL & Huge community support, simple syntax & No 100\% compatible with SQL language\\
        Microsoft SQL Server  & Good documentation, goodl cloud support & Proprietary, not free to use\\
        \hline
    \end{tabularx}
\end{table}

After some careful considerations, PostgreSQL is chosen.
This is mainly due to the support for custom data types.
There many third party extensions that add data types for geospactial data such as PostGIS.
The web application will be mainly storing geospacial data, making this feature useful for the project.

Another advantage of PostgreSQL is the availability of online database services.
This is a huge limitation to SQLite which is useful when storing data locally in a file.
Microsoft SQL Server also has limited availablity due the cost of the license.

MySQL is also a good option for this project.
However, the lack of SQL language support limits its usage.
SQL allows for querying data from the database in a database agnostic way.
The lack of SQL support also limits the interactions to certain ORM which limits programming language supports.
Another disadvantage of MySQL is the slow development.
A slow development cycle limits how fast bugs and new features can come out.
It is important to have fast response when a new bug especially security bugs is found.
\end{logbook-entry}

\begin{logbook-entry}{Initial API}{8}{23/10/2023}{27/10/2023}
An intial API for the web-server is designed.    
The API is designed to communicate using the JSON format.
The user and boat will make HTTP post and get request to add data and receive data.

The API is split different parts.
Each parts has their respective get and post method to fetch and create data from the database.
The different parts are shown in table \ref{tab:api-parts}.

\begin{table}[H]
    \centering{}
    \caption{API Parts and Their Usage}
    \label{tab:api-parts}
    \begin{tabularx}{\textwidth}{m{5em} X X}
        \hline
        API Part & Description & HTTP Path\\
        \hline
        Trips & The data collection trips the boat went on & \lstinline{/api/trips}\\
        Paths & The predfined paths the boat can follow & \lstinline{/api/paths}\\
        GPS & The current location of the boat & \lstinline{/api/gps}\\
        Data & The data collected by the boat & \lstinline{/api/data}\\
        \hline
    \end{tabularx}
\end{table}

Databases store data in tables.
The table contains columns in which data is stored.
Each column has its own data type and relation to other table columns.
The table layouts are difned in a database schema which ensures the tables and columns are created on the database.

\begin{lstlisting}[language=sql,caption={Database Schema of the Database}]
DROP TABLE IF EXISTS data;
DROP TABLE IF EXISTS history;
DROP TABLE IF EXISTS trips;
DROP TABLE IF EXISTS paths;
DROP TYPE IF EXISTS layer;

CREATE TYPE layer AS ENUM ('surface', 'middle', 'sea bed');

CREATE TABLE IF NOT EXISTS history (
  time TIMESTAMPTZ PRIMARY KEY,
  location JSON NOT NULL
);

CREATE TABLE IF NOT EXISTS paths (
  uuid UUID PRIMARY KEY,
  name NAME NOT NULL,
  path JSON[] NOT NULL
);

CREATE TABLE IF NOT EXISTS trips (
  uuid UUID PRIMARY KEY,
  time TIMESTAMPTZ NOT NULL,
  path UUID NOT NULL REFERENCES paths
);

CREATE TABLE IF NOT EXISTS data (
  id SERIAL PRIMARY KEY,
  temperature FLOAT8 NOT NULL,
  location JSON NOT NULL,
  depth FLOAT8 NOT NULL,
  layer layer NOT NULL,
  time TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  trip UUID NOT NULL REFERENCES trips
);
\end{lstlisting}

The \lstinline{sqlx} library is used to interact with the database.
It provides away to fetch data from the database using SQL in Rust.
The \lstinline{sqlx} library has drivers for many popular databases including PostgreSQL.
A huge benifit of the \lstinline{sqlx} library is that it can check the syntax of the SQL command at compile time.
This reduces the amount of errors made as the SQL command would be checked before the server is deployed.
\end{logbook-entry}

\begin{logbook-entry}{Stakeholder Meeting}{11}{13/11/2023}{17/11/2023}
This week, there is another stakeholder meeting.
In this meeting, the stake holder answers questions from us.
The stake holder helped clarified some questions for us on what the project scope should be.

However, during the stake holder meeting, he mentioned something that requires us to change the direction of the project.
The stakeholder mentioned that the boat needs to be able to function in remote areas.
This implies that the boat should function in places without any internet/data connection.

Our previous ideas requires an internet connection to send path and receive data to and from the boat.
This is not possible with the new design requirments rendering our current design invalid.
Luckily this only effects the communication between the boat and the laptop.

We discussed on other potential solutions.
After some discussions, we settled on making a desktop application instead.
A desktop application is able to operate offline.
Hower, we are still discussing on potential soultions of communicating between the boat and the laptop.
\end{logbook-entry}

\begin{logbook-entry}{Desktop Application Research}{12}{20/11/2023}{24/11/2023}
We decided to create a desktop application.
There are a lot of frameworks to help with designing a desktop application.
Ideally, the application is has cross platform capabilities and is able to access OS functionalities.
Furthermore, the desktop should also be able to function offline without any internet.

\begin{table}[H]
    \centering{}
    \caption{Comparison Table for Different Frameworks}
    \label{tab:desktop-framework-table}
    \begin{tabularx}{\textwidth}{l X X}
        \hline
        Framework & Advantages & Disadvantages\\
        \hline
        Qt & Native Application & Limited map support, hard to compile for cross platform\\
        Electron & Uses web technologies, easy to use & Slow and big binary sizes\\
        Tauri & Uses web technologies, faster and smaller binary & Slow compilation\\
        \hline
    \end{tabularx}
\end{table}

I tried out different frameworks by making simple UI with them.
Then the frameworks are compared with each other.
In table \ref{tab:desktop-framework-table}, I list the advantages and disadvantages of each of the framework.

However, I chose to use the Tauri framework at the end.
The Qt framework is not chosen because tthe lack of map support.
One of the central features of the desktop application is a map to display data and boat path.
The cross platform capabilities is fine for the prototyping phase.

The Electron framework, works well with various map display frameworks.
This is due to the wide support of slippy map libraries for JavaScript and the web.
However, the Electron framework bundles in the chromium web engine making the binary size big.
Further more, JavaScript is used as the language to interface with the OS.
JavaScript is not known for it's speed and performance.

Tauri on the other hand, uses web technologies while using the OS built in web engine instead.
This reduces the binary size.
Futhermore, the speeed and performance of Rust makes algorithms run faster.
Lastly, it has good multithreading support for running multiple tasks at the same time.
Eventhough the Tauri framework is newer and has less support, I think the advantages out-weighs the disadantages.

Another option considered was progressive web apps (PWA).
These are web applications that runs in the browser and can be installed.
Unlike normal web applications, PWA can operate offline.
However, due to the security features of the web browsers, accessing the OS is hard.
OS functionalities such and saving and reading files and accessing serial ports is hard to implement and some browsers might not support it.
\end{logbook-entry}

\begin{logbook-entry}{Map Tiles Research}{13}{27/11/2023}{01/12/2023}
For a map to display, it requires tiles.
Most slippy maps libraries uses an online source and request the tiles dynamically when needed.
However, this is not possible due to design requirements.

There are two main types of tiles according to the OpenStreetMap wiki.
The first type of tile is called the raster tiles.
These tiles are prerendered tiles.
They are stored in the form of images or compressed images.
File formats for raster tiles are ".png", ".jpg" and ".pbf" for compressed images.

The second type of tile is called vector tiles.
Vector tiles store the map data in the form of vectors.
These vectors can be in the form of shapes, lines, text and many more.
The user would have to render the map on the fly using the vector data.
Due to the nature of vectors, the resolution of the map is still high when zoomed in.

\begin{table}[H]
    \centering{}
    \caption{Comparison Table for Different Map Tiles}
    \label{tab:map-tiles-table}
    \begin{tabularx}{\textwidth}{l X X}
        \hline
        Tiles & Advantages & Disadvantages\\
        \hline
        Raster & Quick to render, easy to use & Big storage usage, low resolution when zoomed in\\
        Vector & High resoultion when zoomed in, uses less storage space & Requires rendering everytime\\
        \hline
    \end{tabularx}
\end{table}

I compared the advantages and disadvantages for each of the tiles.
The comparison is put in table \ref{tab:map-tiles-table}.
Due to the limitiations of the design requirements, the vector tile format is chosen.

Eventhough raster tiles renders quickly, the huge storage space required is the main limiting factor.
For a map to use raster tiles offline, all the images on each map zoom layer needed to be downloaded.
This requires a lot of file space and is impractical even for a limited are such as the entire Malaysia.

Vector tiles requires rendering on the fly.
However, most modern laptop should be able to do this quickly.
Furthermore, since the tiles are rendered on the fly, the user can specify how they want the map to look.
This is not an important feature but would be a nice feature to have.

The high resolution of the vector tiles also benifits the project.
Often times, the stake holder might want to have fine grain control over where they want to collect data.
Being able to zoom in the map while maintaining high resolution helps with points selection when creating the path of the boat.

Due to the usage of vector tiles, a new library is used for displaying the slippy map.
The Maplibre JS library is chosen due to its wide community support.
It is a free and open-source project, that can render vector tiles using WebGL.
\end{logbook-entry}

\begin{logbook-entry}{Tileset Research}{14}{04/12/2023}{08/12/2023}
The downloaded tiles must be stored in a file format for effective retrieval and storage.
A set of tiles stored in a specific file format is called a "tileset".
There are many ways of storing tiles and each of them support different types of tiles.
    I compared the different formats and list them in table \ref{tab:tileset-table}.

\begin{table}[H]
    \centering{}
    \caption{Comparison Table for Different Tileset}
    \label{tab:tileset-table}
    \begin{tabularx}{\textwidth}{l X X}
        \hline
        Tileset & Advantages & Disadvantages\\
        \hline
        MBTiles & Works for both vector and raster tiles, uses sqlite and is widely supported & Requires querying sqlite database for each fetch\\
        PMTiles & Single file format, headers can be used to only fetch required data & Requires additional library to work, requires conversion from other file formats\\
        GeoJSON & Human readable format, easy to parse, widely supported & Written in plain text (big file)\\
        File System Folder & Simple to implement, easy to view all the tiles & Reading from disk is slow, creates a lot files\\
        \hline
    \end{tabularx}
\end{table}

The PMTiles is the chosen tileset format for the desktop application.
This is due to the single file format which makes distributing the data easy.
The Maplibre JS library has a plugin for displaying PMTiles, which makes integrating easy.

GeoJSON is not chosen due to its plain text format.
When the data is uncompressed, the tileset is going to take up a lot of storage space.
A larger map data means that either the binary size would be bigger or the user needs to download a bigger file when the application first launch.
Using a different tileset reduces the need for bandwidth or additional hardware.

Storing the tiles in the file system is simple to implement, however the performance is not good.
The user of the desktop must render the map on the fly.
Often times a view of a map requires multiple new tiles which means a few fetches from the file system.
This will slow down the time it takes to render the map and decrease the user experience.

MBTiles is another tileset considered for the desktop application.
It is widely supported, and most tile downloads are in this format.
However, there is no built-in way of accessing MBTiles in Maplibre JS.
This makes using MBTiles hard and requires implementing my own MBTiles fetching library.
\end{logbook-entry}

\begin{logbook-entry}{UI Design}{15}{11/12/2023}{15/12/2023}
This week, I worked on the main user interface looks and layout.
There is no logic implemented yet and only the layout and looks are designed.
A simple scratch of the user interface is drawn on paper to brain storm potential desgins.
A scratch helps presents potential solution for the user interface for other people to review.

Some scratches are dicussed within the team.
The team discussed some pros and cons of each designs and give critism on how it can be imporved.
Once a scratch design is finalized, the UI is implemented in HTML and CSS.

The desktop application backend used is Tauri.
Tauri uses web technolgies such as HTML, CSS and JavaScript for the user interface.
This enables the usage of the various frameworks and technologiees made for the web.

The scratch is quickly ported to HTML and CSS.
The tailwindCSS is used to help with designing the UI with CSS.
Tailwind provides many classess to change the layout, colours and margins of an element.
This makes designing a good looking UI simple and easy.

Some minor changes were made to the scratch when porting to the desktop application.
These are minors such as paddings and margins to help align the elements better.

The map is also added to the initial UI design.
However, the map doesn't have any logic yet.
It is just a simple slippy map that can be moved around and zoom in and out.
The map is rendered using the MapLibre JS library.
The MapLibre JS library is a library used to render vector maps.
The tiles are provided from the file system accessed through the Tauri framework.
\end{logbook-entry}

\begin{logbook-entry}{Map Logic}{22}{29/01/2024}{02/02/2024}
One of the main goals of the desktop application is to set the path the boat is going to follow.
This will inform the boat where the temperature data should be collected.

The user can input waypoints for the boat to reach.
This will determine the path the boat will follow.
The Maplibre JS provides a way to listen when the user clicks on the map.
A new waypoint can be added at the location the user clicked on.

The path can then be generated using the waypoints.
Currently, the path follows the order the points is added.
This will cause the path to intersect.
This is not ideal as this will cause duplication of data points.
A better algorithm is needed to generate a path that does not intersect.
\end{logbook-entry}

\begin{logbook-entry}{Map Logic 2}{23}{05/02/2024}{09/02/2024}
When planning a path for the robot boat to follow, it is essential to move waypoints around.
This allows users to try out different configurations with different way point positions.

Maplibre has a special map item for marking points that can be moved around.
A marker can be used to mark specific important points on the map.
The marker can then be dragged around the map.

When a marker is moved, the new location of the marker can be used as a new waypoint.
This can be done using the "drag" event emitted by the marker.
The "drag" event contains information about the new coordinate the marker is on.
The path then can update accordingly based on the new coordinate.
\end{logbook-entry}

\begin{logbook-entry}{Import Export}{25}{19/02/2024}{23/02/2024}
The map on the desktop application is only capable of display on route at a time.
However, the stakeholder might want to collect data from multiple different water-body and or set multiple paths for the same water body.

The desktop application should have a way to import and export paths.
This allows the user to save paths for different data collection tasks.

GeoJSON is a file format for describing geographical features.
There are several types of features:

\begin{itemize}
    \item Point
    \item LineString
    \item Polygon
    \item MultiPoint
    \item MultiLineString
    \item MultiPolygon
    \item GeometryCollection
\end{itemize}

Maplibre JS has built in support for displaying data in GeoJSON, making it a suitable file format for storing the path.
The GeoJSON file being imported and exported is made out of a FeatureCollection.
The feature collection contains the following features:

\begin{itemize}
    \item MultiPoint feature used to describe all the location where the data is going to be collected.
    \item LineString feature used to describe the path the boat is going to follow.
    \item A version foreign member to describe what version of the file format being used (useful for future changes to the file format).
\end{itemize}

This format is used both internally by the application and external for user import and export.
Every time the user changes the path and or collection point, the path is saved to the application's internal storage.
Exporting and importing paths can be done using buttons.
The buttons will display a file picker to choose where to save the file to or which file to import from.

The state of the path used by Maplibre is serialized and deserialized using the serde library.
However, whenever something is imported, a function would check the validity of the GeoJSON file.
This is to ensure the required items are present in the file being imported.

\subsection*{Resources}

\begin{itemize}
    \item \href{https://datatracker.ietf.org/doc/html/rfc7946}{GeoJSON RFC}
\end{itemize}

\end{logbook-entry}

\begin{logbook-entry}{Heatmap}{26}{26/02/2024}{01/03/2024}
A heatmap is a good way to display the temperature variation in an area.
A heatmap can be used to display temperature information using different colour.
For example, a red area represents high temperature while a blue area represents a cold area.

A heatmap is a good feature for the desktop application to quickly interpret the data received from the robot.
However, for further analysis of the collected data, the data has to be exported.

Maplibre JS provides a way to display heatmap data.
A heatmap layer for Maplibre can customize the colour of the heatmap based on density of the heat map in a spot.
The heatmap weight and intensity controls the density of the heatmap at a point on the map.
The heatmap colour can be modified to change the colour based on the density of the heatmap.
Lastly, the radius of each data point controls how spread out the heatmap is, and the opacity controls the opacity of the heatmap.

Scientists and data analysis used spreadsheet program to process data.
There are many formats available that are compatible with spreadsheets.
Some notable examples are:

\begin{itemize}
    \item Excel Spreadsheet (.xls/.xlsx)
    \item XML (.xml)
    \item Comma-separated Values (CSV) (.csv)
    \item OpenDocument (.ods)
\end{itemize}

The main format to import and export data from the desktop application is Comma-separated Values.
It is a plain text file format that is easy to understand and universal.
Most/all spreadsheet programs have built in support for parsing CSV.
There are also plenty of libraries in many programming languages such as Python to parse CSV as well.
The universality and standardization of this file format is the main reason why CSV is used.

An additional file format is used for internal used of the application.
The file format is GeoJSON.
This is due to the fact that the Maplibre JS library expects data to be in this format.
Saving the results in this format makes sense and simplifies the logic to display the heatmap.

\subsection*{The CSV Format}

The CSV file format is a plain text format to store data.
Each line represents a specific record of data.
The values for each record are separated using commas, hence the name comma-separated values.
An optional heading row can be set using the first row of the CSV file.

The data exported from the desktop application have the following values:

\begin{itemize}
    \item The temperature in \textdegree{C}
    \item The depth in millimetres
    \item The layer in water body the temperature is collected at (Sea Bed, Middle or Surface)
    \item The timestamp of the data in Unix Time
    \item The latitude coordinate of the data point
    \item The longitude coordinate of the data point
\end{itemize}
\end{logbook-entry}

\begin{logbook-entry}{Path Generation}{27}{04/03/2024}{08/03/2024}
The path generation and points interpolation algorithm is worked on.

\subsection*{Path Generation}
A simple algorithm is used to generate the path followed by the boat.
The algorithm can be split into a few main logic.

\begin{enumerate}
    \item Pick an initial starting point of the boat (the first point inserted by the user)
    \item Find the nearest point to the initial point (using Haversine formula (provided by Maplibre JS library))
    \item Add the nearest point to the path
    \item Use repeat step 2 with the new point as the new initial point
    \item The algorithm ends when all the input points are used
\end{enumerate}

The algorithm is simple and works but will sometimes generate path that intersects.
This is not ideal as this would mean the boat will collect redundant data (data in the same coordinate).
However, this is good enough for now but a better algorithm can be used.

\subsection*{Point Interpolation}
The Haversine Formula can be used to interpolate the points in between the path.
This can be done by using the bearing from the staring to the ending point of the path and the distance from the starting point.
The equations are shown below:

New Latitude:
\begin{equation}
    \phi{}_{2} = \arcsin{(\sin{\phi{}_{1}} \cos{\delta} + \cos{\phi{}_{1}} \sin{\delta} \cos{\theta})}
\end{equation}

New Longitude:
\begin{equation}
    \lambda{}_{2} = \lambda{}_{1} + \arctan{(\frac{\sin{\theta} \sin{\delta} \cos{\phi{}_{1}}}{\cos{\delta} - \sin{\phi_{1} \sin{\phi_{2}}}})}
\end{equation}

Variables:

$\delta = d / R$

$d = $ distance from the starting point

$R = $ the radius of Earth

$\phi_1 = $ The latitude of the starting point

$\lambda_1 = $ The longitude of the starting point

$\theta = $ The bearing from north

\subsection*{Resources}
\begin{itemize}
    \item \href{https://stackoverflow.com/questions/14263284/create-non-intersecting-polygon-passing-through-all-given-points}{Better Path Generation}
    \item \href{https://www.movable-type.co.uk/scripts/latlong.html}{Haversine Formula}.
\end{itemize}
\end{logbook-entry}

\begin{logbook-entry}{Communication Protocol}{28}{11/03/2024}{15/03/2024}
The communication protocol is worked on.
The main task of the communication protocol is to facilitate communication between the desktop application and the robot boat.
The desktop application would send the route generated by the user to the boat.
The boat would send the data collected to the desktop application for further processing.

\subsection*{Communication Medium}

There are a few ways to send data between the boat and the desktop application.
Some mediums considered were:

\begin{itemize}
    \item Radio Frequency Communication using nRF24L01
    \item Serial Communication through USB Cables
    \item Bluetooth Connection with the Raspberry Pi
    \item Simple TCP Connection using Wi-Fi with the Raspberry Pi
\end{itemize}

\begin{table}[ht]
    \centering
    \caption{Table Comparing All the Communication Mediums}
    \label{tab:comm-medium}
    \vspace{1em}
    \begin{tabular}{ p{7em} p{10em} p{10em} }
        Communication Medium & Advantages                                               & Disadvantages                                                              \\
        \hline
        RF                   & Wireless, Does not need connection with the Raspberry Pi & Slow and Limited Packet Size                                               \\
        \hline
        USB Cable            & Simple and Practical                                     & Requires physical access to the boat                                       \\
        \hline
        Bluetooth            & Wireless, Easy discovery of robot                        & Requires Bluetooth connection with the Raspberry Pi, short range           \\
        \hline
        TCP                  & Wireless, Fast data transfers                            & Requires LAN connection with Pi, medium range, compatible with all laptops \\
        \hline
    \end{tabular}
\end{table}

A comparison between all the communication mediums are shown in table \ref{tab:comm-medium}.
Each of the mediums were carefully considered and compared.
The serial communication using USB cables are chosen at the end.

The RF communication isn't considered due to the low packet sizes and sending speed.
This can be circumvented by splitting the data into multiple packets.

However, sending multiple packets will take time as each packet send has an estimated delay of around 1 ms.

TCP connection isn't considered due to requiring connecting the Raspberry Pi to the same WLAN network (mobile hotspot).
This is hard to achieve without access to the GUI output of Raspberry Pi.

The short range of the Bluetooth protocol limits its usability for our application.
The benefits of being wireless is that data can be transferred while the boat is operating.
The Bluetooth connection would constantly disconnect and or the user needs to stay close to the boat to maintain the connection.

Even though the lack of wireless capabilities of the USB cable, this will not cause too much inconvenience for the user.
Before and after each operation of the boat, the user need to collect/place down the boat.
The user will have physical access to the boat and therefore can use the USB cable.
\end{logbook-entry}

\begin{logbook-entry}{Communication Protocol 2}{29}{18/03/2024}{22/03/2024}
For the communication protocol to efficiently communicate between the boat and the desktop application, a format must be agreed on.
The representation of data being transferred plays a huge role the speed at which data can be transferred.

\subsection*{Data Serialization}

There are many ways a data can be serialized and deserialized.
However, there are two main categories, plain text and binary.
Plain text sends data in text format such as English characters.
This is easier to understand and debug by a human.
However, this has the cost of using more bandwidth to transfer each data.
Binary format on the other hand serialize data into binary representation.
This is easier for a computer to parse and requires less bandwidth, hence have a faster speed.
It is hard for a human to understand binary data, and it is harder to debug any issues with the serialized data.
Some data serialization formats considered is shown in Table \ref{tab:data-serialization}.

\begin{table}[ht]
    \centering
    \caption{Table Comparing Some Notable Serialization Formats}
    \label{tab:data-serialization}
    \vspace{1em}
    \begin{tabular}{ p{7em} p{3em} p{10em} p{10em} }
        Serialization Format & Type       & Advantages                                           & Disadvantages                                          \\
        \hline
        JSON                 & Plain Text & Universal, Simple to Read                            & Requires high bandwidth                                \\
        \hline
        Raw Text             & Plain Text & Simple to Implement                                  & Requires good documentation and no standardization     \\
        \hline
        Protobuf             & Binary     & Wide language support and good forward compatibility & Requires a separate protocol file                      \\
        \hline
        Python Pickle        & Binary     & Can serialize into types                             & Limited language support and potential security issues \\
        \hline
    \end{tabular}
\end{table}

The protocol buffer (protobuf) by Google is chosen to be the communication protocol serialization format.
This is due to the wide language support.
The code written on the boat is in Python while the desktop application is written in Rust and JavaScript.
There are built in support for Python and JavaScript, while Rust has a well maintained library for parsing protobufs making it ideal for the use case.
JSON isn't chosen due to the bandwidth and parsing time of large data.
The communication protocol will send large data such as high precision temperature data will cause the bandwidth to be high.
Therefore, it makes communication in JSON not ideal.
\end{logbook-entry}

\begin{logbook-entry}{Communication Protocol Logic}{30}{25/03/2024}{29/03/2024}
I worked on the communication protocol logic on the desktop application.
The protocol messages are drafted and written into ".proto" files.
The protocol consists of 4 main types of messages.

The first message describes a packet being sent to the boat and desktop application.
This message is called "Packet" and consists of a field that describes the type of message being sent and the raw binary message serialized.
To ensure compabtability of future protocols, a version field is included.
The version is a string with the format of three numbers seperated by dots.
The first number is the majore version, the second is the minor version and the last signifies patch (mosty for bugs).
This is also done with other messages in the protocol as well.

The second message type describes a connection message: "Connect".
This message just contains a version string to identify the version of the communication protocol.

The other two messages are data messages.
The "PathData" message contains a list of coordinates for the boat to follow.
The "BoatData" message consists mainly of the "BoatDataFeature" message which contins all the data collected.
The data includes temperature, depth, location, time and water body layer.
Like the other two messages, a version string is also included.

The desktop application starts by searching for any available USB port.
When a USB port is found, a "Connect" packet is sent.
If there is no response within 100 milliseconds, another "Connect" packet is sent.
This process repeats for 10 times, after 10 tries the port is assumed to be unusable/invalid.

Once connected, the application will try to check the connection after some idle time.
This is done by resending a "Connect" packet.
The process is simillar to the initial connection and any unsuable/invalid ports are considered disconnected.

When the user wants to run the boat, a "PathData" packet is sent with all the coordinates of the collection points.
Once, sent the desktop application expects a "Received" packet from the boat to acknowlege that the data is received.
If no acknowlege packet is received, the "PathData" is resent.
If the application receives no replies after 10 tries, the port is considered diconnected.

If any "BoatData" is received from the boat, the application replies with a "Received" acknowlegement packet.
The boat also requires an acknowlegment packet simillar to sending "PathData" and the process is simillar to sending "PathData".
\end{logbook-entry}

\begin{logbook-entry}{Communication Protocol UI}{31}{01/04/2024}{05/04/2024}
This week, I worked on the UI relating to the communication protocol.
There are three main parts of the user interface that is affected by the communication protocol.

The first part is the connection status.
The search for new ports are mainly triggered by the UI.
The available ports are then sent to the UI when found.
The UI can then update the status of the connection bar to connected if any ports are found.
However, when a port is diconnected, an event is send to the UI to indicate the port is disconnected.
The UI listens to this event and updates the status bar element accordingly.

The desktop application also emit an event when new "BoatData" is received.
An event handler on the UI listens to this event and update the heatmap data on the UI.
The new data is then saved to the application storage.

The desktop application also exposes a function to send "PathData".
When the user click on the "Run" button, the UI gets the map data from the map and calls the exposed function provided.
This exposed function will send the data for the connected port with the data from the UI to the boat.
\end{logbook-entry}

\begin{logbook-entry}{Thesis Writing}{32}{08/04/2024}{12/04/2024}
This week, our group decided that we will be focusing on writing the thesis.
All my work on the desktop application is halted.
We feel like the thesis is more important to finish than the project it self.
This is due to the mark allocation of the thesis.
This is not a big deal for me as all the important features of the desktop application is fnished.
\end{logbook-entry}

\end{document}
